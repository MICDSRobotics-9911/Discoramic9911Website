<!DOCTYPE html><html><head><meta charset="utf-8"><title>Github Wiki</title><style></style></head><body id="preview">
<link rel="icon" href="favicon.ico">
<p>Welcome to the MicdsRobotics wiki!</p>
<p>If you’re looking to start coding some programs for the robot, head over to <a href="https://github.com/blabel3/MicdsRobotics/wiki/Setting-Up-Android-Studio">Setting Up Android Studio</a>!</p>
<p>We have tons of guides on everything from how to get all this downloaded on your computer to how to become a super powerful contributor to this repository! Just navigate with the sidebar and you’ll be on your way!</p>
<h1><a id="How_to_Github_6"></a>How to Github</h1>
<p><a href="https://github.com">Github</a> is a very powerful tool used to collaborate on code. Now you can just use the desktop version of github, but today we’ll learn the command prompt way</p>
<h1><a id="Getting_Started_10"></a>Getting Started</h1>
<p>You will need Git for Windows <a href="https://git-scm.com/download/win">Click here to go to the installer for windows</a></p>
<p>Think of Github as a remote storage space, like Google Drive for code. Except in this case, we will be using Git Bash to control the flow of work. To start, search and open Git Bash on you computer.</p>
<p>Now go to <a href="http://Github.com">Github.com</a> and sign in to the micdsrobotics git repository page. Click on “Clone or Download” and select HTTPS and copy the link.</p>
<p>Open your Git Bash Command Window, and navigate to the desired parent directory (like c:/users/person/desktop/github and type:</p>
<pre><code>git clone https://github.com/blabel3/MicdsRobotics.git
</code></pre>
<p>That first part ‘git’ tells the bash that we want to use the git and clone makes a copy of the desired repository</p>
<h1><a id="Next_Steps_25"></a>Next Steps</h1>
<p>Now open up the file and make a change.</p>
<p>Right click the File Explorer and click ‘open git bash here’</p>
<p>Type:</p>
<pre><code>git status
</code></pre>
<p>This command will tell you what you changed.</p>
<h1><a id="Publishing_these_changes_36"></a>Publishing these changes</h1>
<p>Now, to send these changes to the repository, there are three phases:</p>
<ol>
<li>Adding files to commit
<ul>
<li><code>git add {file names}</code></li>
</ul>
</li>
<li>Making the commit locally
<ul>
<li><code>git commit -m &quot;{insert commit comment here}&quot;</code></li>
</ul>
</li>
<li>Push local commit to remote repository
<ul>
<li><code>git push</code></li>
</ul>
</li>
<li>Adding files to
<ul>
<li><code>git add *</code></li>
</ul>
</li>
<li>Push
<ul>
<li><code>git push</code></li>
</ul>
</li>
</ol>
<h1><a id="Creating_a_Configuration_File_51"></a>Creating a Configuration File</h1>
<p>Configuration files are needed so that the robot knows how to interact with all of the harware you connected to it. It handles all of the little things about actually connecting the code we just wrote to actual, physical movement on the robot. FTC provided us with a very simple way of editing the configuration files through the phone, so let’s start there.</p>
<h2><a id="Getting_to_the_Configuration_Editor_55"></a>Getting to the Configuration Editor</h2>
<p>In either the Robot Controller app or the Driver Station app, click the three dots in the top right corner to open the menu.</p>
<p><img src="http://i.imgur.com/sjxfnFP.png" alt="Driver Station"></p>
<p><img src="http://i.imgur.com/RftdjKF.png" alt="Driver Station Menu"></p>
<p>From there, you want to hit “Configure Robot”, which will send you to the configuration manager. Here you can make new configurations, delete old ones, edit ones, and activate different ones you’re using. To make a new file, you have to connect the Robot Controller phone to the Core Power Distribution Module and turn it on while connected to all of the other modules, then hit <code>New</code>, and then scan for the hardware connected to the robot.</p>
<p><img src="http://i.imgur.com/5uFrAFw.png" alt="Inside Configuration"></p>
<h2><a id="Using_the_Editor_67"></a>Using the Editor</h2>
<p>After you scan, all of your hardware should show up in the editor. If you don’t see it, make sure that the core power distribution module is turned on and that all of your other modules are securely connected.</p>
<p>Next, you’re going to set every peice of hardware’s name. It has to correspond to what you put in your code – so if your code looks like this:</p>
<pre><code>leftMotor  = hardwareMap.dcMotor.get(&quot;left motor&quot;);
rightMotor = hardwareMap.dcMotor.get(&quot;right motor&quot;);

spinner = hardwareMap.dcMotor.get(&quot;spinner&quot;);
flywheel = hardwareMap.dcMotor.get(&quot;flywheel&quot;);

beaconSlider = hardwareMap.crservo.get(&quot;slider&quot;);
</code></pre>
<p>Then you want to make sure in your configuration file, you name your motors <code>left motor</code> and <code>right motor</code>, or else you won’t be able to use those motors. Once you’re done, your modules will look something like either of these:</p>
<p><img src="http://i.imgur.com/xiVbmcq.png" alt="Module Confiuration"></p>
<p><img src="http://i.imgur.com/KJUu0kW.png" alt="Servo Module config"></p>
<h2><a id="Save__Activate_87"></a>Save &amp; Activate</h2>
<p>Once you’re done, don’t forget to hit save and activate it when you’re back at the main menu for the configuration editor! Otherwise you’ll have to re-do all of your file, or the robot might not even use it!</p>
<h2><a id="Recap_91"></a>Recap</h2>
<p>Create the configuration file through either of the phones while all of the DC Motor Controllers, Servo Controllers, Legacy Module Controllers, etc. are connected, then save it and activate your new file. You’re ready to go!</p>
<h1><a id="Remote_Debugging_from_your_Computer_using_adb_96"></a>Remote Debugging from your Computer (using adb)</h1>
<h2><a id="What_Its_Used_For_97"></a>What It’s Used For</h2>
<p>Wireless uploading to the phone</p>
<h2><a id="Setting_Up_99"></a>Setting Up</h2>
<p>Make sure you have the Android SDK Tools installed.<br>
Plug the phone into the computer.<br>
Open up the command line and type</p>
<pre><code>adb tcpip 5555
</code></pre>
<p>This will set the port. Then, find the phone’s IP Address and <strong>make sure that the computer and the phone are on the same network</strong>.<br>
Now do:</p>
<pre><code>adb connect [IP of the phone]
</code></pre>
<p>Now you are connected. If this fails, try using</p>
<pre><code>adb kill-server
</code></pre>
<p>and then</p>
<pre><code>adb start-server
</code></pre>
<p>also,</p>
<pre><code>adb get-state
</code></pre>
<p>might also be of assistance.</p>
<h2><a id="Usage_124"></a>Usage</h2>
<p>This connection will act as a regular USB connection. So treat it if it were plugged into your computer.</p>
<p><a href="https://developer.android.com/studio/command-line/adb.html#Enabling">More Info Here</a></p>
<p>There are three main things that you’ll need to edit the code inside of Android Studio. FTC teams can use either MIT App Inventor or Android Studio to create their OpModes and put them on the phones and everything, and our team prefers Android Studio. It’s generally faster and easier to work with, if you’re willing to learn Java and explore all of the documentation FTC provided us with. To use it we’ll need four things:</p>
<ol>
<li>
<p>The latest JDK</p>
</li>
<li>
<p>Android Studio</p>
</li>
<li>
<p>Some SDKs for Android Studio</p>
</li>
<li>
<p>This repository</p>
</li>
</ol>
<p>In this guide, we’ll go through installing each of those.</p>
<h1><a id="Installing_the_JDK_Java_Development_Kit_142"></a>Installing the JDK (Java Development Kit)</h1>
<p>Go to the Java SE Download page here: <a href="http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html">http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html</a></p>
<p>Once you’re there, click on JDK.</p>
<p><img src="http://i.imgur.com/i2Augw9.png" alt="Java Development Kit"></p>
<p>There will be a lot of versions for you to pick from on the page that follows. Just click Accept License Agreement and pick the one that corresponds to your computer. Probably one of the Windows ones, and most likely the x64 one. You can tell if you need x64 or x86 by going into System Properties or About Your PC on Windows, Somewhere in System Preferences on Mac, and if you’re on Linux, you probably don’t need me to tell you. :)</p>
<p><img src="http://i.imgur.com/jB4ht4o.png" alt="Downloads"></p>
<p>The download will start, once it’s done just save and open that file, and let the download wizard guide you through the installation. You can keep the defaults for everything. In fact, I’d recommend that you do keep the default for everything, so that Android Studio has a better time recognizing where you installed it.</p>
<p>And that’s it! The JDK is all set.</p>
<h1><a id="Installing_Android_Studio_158"></a>Installing Android Studio</h1>
<p>Next up: Android Studio. This is the official IDE for working with Android phones, and what FTC endorses, so we definitely need it. To download it, go here: <a href="https://developer.android.com/studio/index.html">https://developer.android.com/studio/index.html</a>.</p>
<p>We can use the latest version for everything, there’s no specific version that we need to use or anything. So just clicking the huge download button works great.</p>
<p><img src="http://i.imgur.com/8BiWRNe.png" alt="Android Studio Download"></p>
<p>Follow the new download’s instructions on installing Android Studio, and you’ll be set! It takes a little while to download and more time to install, so just be patient.</p>
<h1><a id="SDKs_for_Android_Studio_168"></a>SDKs for Android Studio</h1>
<p>FTC teams need a few SDKs in order to work with the apps. They’re all found inside of Android Studio, so after that is installed, go ahead and launch it. Once you get the splash screen, click Configure in the bottom right corner, or if it’s been changed since this guide was made, whatever option looks like it’ll lead to settings.</p>
<p>Then hit SDK Manager, which will lead us to a screen where we can pick the SDKs that we want.</p>
<p><img src="http://i.imgur.com/7VS2cEu.png" alt="Configure"></p>
<p>From there, hit Launch Standalone SDK Manager in the bottom left corner.</p>
<p><img src="http://i.imgur.com/5T9DCiR.png" alt="Standalone SDK Manager"></p>
<p>From there, select these packages:</p>
<ul>
<li>
<p>Under <code>Tools</code>:</p>
</li>
<li>
<p><code>Android SDK Build-tools 21.1.2</code></p>
</li>
<li>
<p>Under <code>Android 5.0.1 (API 21)</code>:</p>
</li>
<li>
<p><code>SDK Platform</code></p>
</li>
<li>
<p><code>Google APIs</code></p>
</li>
<li>
<p>Under <code>Extras</code>:</p>
</li>
<li>
<p><code>Google USB Driver</code></p>
</li>
</ul>
<p>I’d also recommend getting these, since they were needed last year, although they were not required this year:</p>
<ul>
<li>
<p>Under <code>Android 4.4.2 (API 19)</code>:</p>
</li>
<li>
<p><code>SDK Platform</code></p>
</li>
<li>
<p><code>Sources for Android SDK</code></p>
</li>
</ul>
<p>It’ll look something like this, only with install not greyed out – mine only is since I already have them installed.</p>
<p><img src="http://i.imgur.com/8IiKGW9.png" alt="SDKs Selected"></p>
<p>You can go ahead and hit install to install the packages. Your Android Studio is all set up! Now we just need the project to open in it.</p>
<h1><a id="Getting_this_Repository_208"></a>Getting this Repository</h1>
<p>To do that, you’ll want to clone this repository to your computer. For instructions on how to do that, head over our section on setting up Github and learning some basic functions for it.</p>
<ul>
<li><a href="https://github.com/blabel3/MicdsRobotics/wiki/Github---Getting-Started">Getting started with Github</a></li>
</ul>
<h1><a id="Making_a_fully_Autonomous_OpMode_215"></a>Making a fully Autonomous OpMode</h1>
<p><strong><em>Important Documentation:</em></strong></p>
<ul>
<li><code>file:///C:/Users/&lt;YOUR_USERNAME&gt;/Documents/GitHub/MicdsRobotics/ftc_app-master/doc/javadoc/index.html</code>  or <code>http://ftctechnh.github.io/ftc_app/doc/javadoc/index.html</code> <em>(Everything)</em></li>
<li><code>file:///C:/Users/&lt;YOUR_USERNAME&gt;/Documents/GitHub/MicdsRobotics/ftc_app-master/doc/javadoc/com/qualcomm/robotcore/eventloop/opmode/LinearOpMode.html</code> <em>(TeleOp)</em></li>
</ul>
<p>(Usually, it’s a good idea to start with creating TeleOp)</p>
<h2><a id="Import_Statements_223"></a>Import Statements</h2>
<p>There are a lot of things you’ll probably want to import, but you’ll almost always want some of these:</p>
<pre><code>import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.HardwareMap;
import com.qualcomm.robotcore.util.ElapsedTime;
import com.qualcomm.robotcore.util.RobotLog;
</code></pre>
<p>Android Studio will also usually prompt you if something’s not imported.</p>
<h2><a id="Making_the_Class_237"></a>Making the Class</h2>
<p>For Autonomous, you start with this:</p>
<p><code>@Autonomous(name=&quot;&lt;What you want it to show as on the app&gt;&quot;, group=&quot;&lt;The group you want it in (useful for sorting and grouping)&gt;&quot;)</code></p>
<p>You can add <code>@Disabled</code> if you want it to not show up in the app. Then you start it off with your actual class declaration:</p>
<p><code>public class selfDriving extends LinearOpMode { ... }</code></p>
<p>LinearOpMode has a few methods that OpMode doesn’t have, such as <code>sleep()</code>, which really help out when you can’t rely on a driver to control the robot</p>
<p>You could also just copy the one of the template OpModes from <code>\ftc_app-master\FtcRobotController\src\main\java\org\firstinspires\ftc\robotcontroller\external\samples</code> - Look for a linear OpMode template.</p>
<h2><a id="Declaring_Hardware_251"></a>Declaring Hardware</h2>
<p>Just like writing a Driver-Controlled OpMode, we have to declare our hardware. It’s almost the exact same process here, although it’s very important to make sure that your two OpModes line up. If they do, you can use the same configuration file without any issue, but if you don’t there could be issues if you attempt to use the same configuration file. You could make two and remember to switch it when you want to run the other program, but it’s a lot easier just to match the hardware in the code.</p>
<p>So, anyway, we just declare an object like normal, of whatever we need. Their value should be set to null for now, because it’s better to set the hardware values after initializing so that you can change the configuration file on the fly from the phone. It’ll look something like this:</p>
<pre><code>private DcMotor leftMotor = null;
private DcMotor rightMotor = null;

private CRServo spinner = null;
private Servo hitter = null;
</code></pre>
<p>It’s also a good idea to define any constants you want to use during autonomous here. Some good ideas we usually use are numbers for motor encoders, or specific times if you’re not using any of them. Here’s an example:</p>
<pre><code>final int MOTOR_PULSE_PER_REVOLUTION = 7;
final int MOTOR_GEAR_RATIO = 80;
final int FULL_REVOLUTION = 1200;
final int FLOOR_BLOCK = 2292;
</code></pre>
<p>Now on to initialization!</p>
<h2><a id="Initialization_272"></a>Initialization</h2>
<p>During initialization, we link those objects we just created to actual hardware connected to the robot (based on the configuration file). Make sure to remember what you put as parameters for <code>get()</code>, because that’s the key to linking this to the configuration file.</p>
<p>This time though, there’s in <code>init()</code>. Instead, we just put the code inside <code>runOpMode()</code>.</p>
<pre><code>@Override
public void runOpMode() throws InterruptedException {
</code></pre>
<p>The <code>InterruptedException</code> allows for methods like <code>sleep()</code> to run without an issue and without messing with other things like runtime.</p>
<h3><a id="Assigning_our_objects_to_real_objects_283"></a>Assigning our objects to real objects</h3>
<p>To link the hardware to the objects, we’ll set the objects equal to one of these statements: <code>hardwareMap.&lt;object type&gt;.get(&quot;&lt;name in config&gt;&quot;);</code>, which effectively just sets the object to the actual object in real life that we need it to be. All the motor values and positions and everything matches up with what’s happening in real life, so the object in the code basically becomes the object in real life for all of our purposes. Now we can work with those values.</p>
<p>The whole statements should look something like this:</p>
<pre><code>leftMotor = hardwareMap.dcMotor.get(&quot;left motor&quot;);
spinner = hardwareMap.crservo.get(&quot;spinner&quot;);
</code></pre>
<h3><a id="Preparing_the_motors_and_servos_292"></a>Preparing the motors and servos</h3>
<p>Now that they’re set up, it’s a good idea to prepare them to actually be used. Technically this step isn’t required, as there are many other ways to get the motors working properly, but it’s a lot easier to reverse directions and set modes here to make the code easier to read and change.</p>
<h4><a id="Setting_Directions_296"></a>Setting Directions</h4>
<p>The first big thing is to set the motor directions. They can either be forward or reverse, and it’s really difficult to know which one you should use before you test, so I recommend just picking one and seeing if it’s correct when you test for the first time. Anyway, to set, you’re going to use <code>setDirection(&lt;direction&gt;)</code>, a method in DcMotor. We don’t really need to understand how this functions directly (although if you’re really interested and have nothing better to do you could probably dig it up somehow), but we do need to understand how to use it.</p>
<p>To use it, you call it on a DcMotor object, with a direction in its parameter. The two directions we have are:</p>
<pre><code>DcMotor.Direction.REVERSE
DcMotor.Direction.FORWARD
</code></pre>
<p>two constants that correspond to forward and backward. After you’re done, the whole statement should look something like this:</p>
<pre><code>leftMotor.setDirection(DcMotor.Direction.REVERSE);
spinner.setDirection(Servo.Direction.FORWARD);
</code></pre>
<h4><a id="Setting_Modes_310"></a>Setting Modes</h4>
<p>The other big thing is to set the all the motors’ modes. There are a few big modes for us to keep in mind:</p>
<ul>
<li><code>DcMotor.RunMode.RUN_WITHOUT_ENCODER</code> - If you don’t have encoders, this is the only mode you can really use. It just sets the power to whatever you pass it in the program directly, with no bells and whistles. This means that you’re skipping out on some of the precision and data that encoders have to offer, but it means saving money if your team doesn’t have any and less work for construction.</li>
<li><code>DcMotor.RunMode.RUN_USING_ENCODER</code> - All the simplicity of not using encoders, with all of the potential of encoders. This allows for very precise movement, with a way to measure the distance traveled without other complicated sensors. Used with other sensors and gyroscopes, the robot’s movement can become even more precise.</li>
<li><code>DcMotor.RunMode.RUN_TO_POSITION</code> - Not always the best for drivetrains in TeleOp, because it’s more difficult to control direction. This will move the motor until it reaches a specific point on the encoders, moving either direction based on which would be more efficient. Still important to keep in mind though, and could come in handy for some routines.</li>
<li><code>DcMotor.RunMode.STOP_AND_RESET_ENCODERS</code> - Super useful for some Autonomous programs, as it resets the encoder values. It lets teams use the encoders in steps, without having to keep track of all the distance the robot has traveled so far. Also nice if you want to reuse some code, like hitting one beacon and then hitting the other; you can just reset and run the exact same stuff.</li>
</ul>
<p>And that’s all of them. So, once you pick the one you think would be most suited for the program, we can actually set it. It’s going to be very similar to setting the direction, just this time we’re using <code>setMode(&lt;mode&gt;)</code>. The end result will be something like this:</p>
<pre><code>leftMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
rightMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
</code></pre>
<p>You’re all set now! Time to get into the fun stuff!</p>
<h2><a id="The_Body_326"></a>The Body</h2>
<p>Now that we’re ready to start, call <code>waitForStart();</code>, which will wait until the user hits play on the phone, and start coding the main body of your autonomous program.</p>
<p>After that, put all of your remaining code inside of a <code>while (opModeIsActive()) { ... }</code> loop, which will just make sure that your autonomous program will keep running until someone hits stop.</p>
<p>At the end of the loop, call <code>idle();</code>. It’s not actually necessary to run, but it just makes the robot wait for a little bit as the hardware cycles again, which lessens the load on the phone’s processor.</p>
<p>Your skeleton Autonomous should look something like this.</p>
<pre><code>while (opModeIsActive()) {
    
    // All the code for your routines
    
    idle();
}
</code></pre>
<h3><a id="Telemetry_343"></a>Telemetry</h3>
<p>Telemetry, the main way of printing things to the phone, is extra important during Autonomous. With no driver to tell you that the motor is working but it’s just not catching on the gear or that the servo isn’t responding at all, it’s super, super important to give yourself some hints as to what’s happening to the robot.</p>
<p>To use telemetry, we will use <code>telemetry.addData(&lt;title&gt;, &lt;value&gt;)</code>, just like we did for TeleOp.</p>
<p>This takes in two strings as it’s parameters: a title and a value. The title is any string you want, but usually it’s good to just type one in yourself that has some relevance to what it represents. No one’s stopping you from making it a meme though. With a title, it’ll look something like this:</p>
<pre><code>telemetry.addData(&quot;Left Motor&quot;, &lt;value&gt;);
</code></pre>
<p>The value can be almost anything as well, from Strings to floats. The ones that are used the most are values returned from <code>getPower()</code> and <code>getCurrentPosition()</code> (for encoders) or <code>getPosition()</code> (for servos), which help a lot for making sure that motors and encoders are working as intended. With the value inserted as well, the statement will look something like this:</p>
<pre><code>telemetry.addData(&quot;Left Motor&quot;, leftMotor.getPower());
</code></pre>
<p>All that’s left is to call <code>telemtry.update();</code>. During Autonomous, it will update the other statements as well when it’s called, so you don’t have to rewrite everything. The final code should look something like this, when you’re done:</p>
<pre><code>telemetry.addData(&quot;Left Motor&quot;, leftMotor.getPower());
telemetry.addData(&quot;Right Motor&quot;, rightMotor.getPower());
telemetry.addData(&quot;Spinner&quot;, spinner.getPosition());
telemetry.update();

. . . //Other parts of the autonomous

telemetry.update();
</code></pre>
<h3><a id="Moving_the_Robot_368"></a>Moving the Robot</h3>
<p>You move the robot the same way that you would in TeleOp, but this time you can’t use the gamepad to cause things to happen. Instead, you will want to write your code based off of sensor data (including motor encoders), time, or perhaps another system entirely.</p>
<ul>
<li>
<p>Sensor Data: There is a huge amount of sensors to use for this, that I couldn’t explain them all. Luckily, FTC provided all of the documentation for them in the links at the top of the guide. They also made sample OpModes using many of the sensors in <code>ftc_app-master\FtcRobotController\src\main\java\org\firstinspires\ftc\robotcontroller\external\samples</code> that can help demonstrate how to use them effectively.</p>
</li>
<li>
<p>Encoders: Encoders are a good idea, especially paired with a gyroscope or other sensor to make sure turns are handled effectively. Depending on which mode you want it to run in (<code>RUN_USING_ENCODERS</code> or <code>RUN_TO_POSITION</code>), you will set it’s target position and it’s power. If you’re using <code>RUN_TO_POSITION</code>, it will move until it gets to the specified target position, and then stop itself. If you’re using <code>RUN_USING_ENCODERS</code>, You can set the target position then set the power like normal, but you will have to stop it once it reaches the target position.</p>
</li>
<li>
<p>Time: Using time is pretty easy. You just set the motors to your desired power level, then call <code>sleep()</code> for however many seconds you want it to do that. The downside is that you have to time every distance you want it to go, which could change if the robot’s hardware changes or if you bump into something while the autonomous program is running. Generally, this method isn’t very accurate at all so it’s not the best decision to <em>only</em> use this.</p>
</li>
</ul>
<p>There are many different ways to structure an autonomous opmode. It’s best to just try a lot of things and use what works the best. Using as many sensors and data as possible is also a great idea to improve accuracy.</p>
<h2><a id="Recap_380"></a>Recap</h2>
<p>You know some of the differences and similarities between TeleOp OpModes and Autonomous OpModes, and how to control a robot using predetermined steps. You also know how to communicate data about the robot in real-time to the phone to debug your programs and help figure out where issues may have arisen. You know all of the structuring for a basic linear OpMode, and can use it to create your own programs.</p>
<p>You know how to make an Autonomous OpMode! Way to go. :)</p>
<p>If you’re still stuck or want to make sure you’re heading in the right direction, you can check <a href="https://github.com/blabel3/MicdsRobotics/blob/master/ftc_app-master/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/RedTeamUnbeacon.java">our Basic Autonomous OpMode</a>.</p>
<h1><a id="Making_a_DriverControlled_OpMode_390"></a>Making a Driver-Controlled OpMode</h1>
<p><strong><em>Important Documentation:</em></strong></p>
<ul>
<li><code>file:///C:/Users/&lt;YOUR_USERNAME&gt;/Documents/GitHub/MicdsRobotics/ftc_app-master/doc/javadoc/index.html</code> or <code>http://ftctechnh.github.io/ftc_app/doc/javadoc/index.html</code> <em>(Everything)</em></li>
<li><code>file:///C:/Users/&lt;YOUR_USERNAME&gt;/Documents/GitHub/MicdsRobotics/ftc_app-master/doc/javadoc/com/qualcomm/robotcore/eventloop/opmode/OpMode.html</code> <em>(TeleOp)</em></li>
</ul>
<h2><a id="Import_Statements_396"></a>Import Statements</h2>
<p>There are a lot of things you’ll probably want to import, but you’ll almost always want some of these:</p>
<pre><code>import com.qualcomm.robotcore.eventloop.opmode.Disabled;  
import com.qualcomm.robotcore.eventloop.opmode.OpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;  
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.HardwareMap;
import com.qualcomm.robotcore.util.ElapsedTime;
</code></pre>
<p>Android Studio will also usually prompt you if something’s not imported.</p>
<h2><a id="Making_the_Class_411"></a>Making the Class</h2>
<p>For Teleop, you start with this:</p>
<p><code>@TeleOp(name=&quot;&lt;What you want it to show as on the app&gt;&quot;, group=&quot;&lt;The group you want it in (useful for sorting and grouping)&gt;&quot;)</code></p>
<p>You can add <code>@Disabled</code> if you want it to not show up in the app. Then you start it off with your actual class declaration:</p>
<p><code>public class driveTest extends OpMode { ... }</code></p>
<p>You could also just copy the one of the template Opmodes from <code>\ftc_app-master\FtcRobotController\src\main\java\org\firstinspires\ftc\robotcontroller\external\samples</code> - Look for an iterative OpMode template.</p>
<h2><a id="Declaring_Hardware_423"></a>Declaring Hardware</h2>
<p>To use motors, we need to somehow find a way to send voltages to the Core Power Distribution Module… luckily, FIRST’s whole app comes with a lot of tools that we just imported to help us do that. All we need to do is declare the objects that we want to use; their objects do a lot of the work behind the scenes.</p>
<p>So to do that, we just declare an object like normal, of whatever we need. Their value should be set to null in the class, because it’s better to get the hardware values after initializing so that you can change the configuration file on the fly. It’ll look something like this:</p>
<pre><code>private DcMotor leftMotor = null;
private DcMotor rightMotor = null;

private CRServo spinner = null;
private Servo hitter = null;
</code></pre>
<p>Now we can go into the initialization.</p>
<h2><a id="Initialization_437"></a>Initialization</h2>
<p>Initialization is the first time we’re really going to have to think. Now is the time we’re going to link those objects we just created to actual hardware connected to the robot (based on the configuration file). Remember what we put inside the strings, because that’s the key to linking this to that configuration file, which we will create at the end.</p>
<h3><a id="Assigning_our_objects_to_real_objects_441"></a>Assigning our objects to real objects</h3>
<p>To do that, we’ll set the objects equal to one of these statements: <code>hardwareMap.&lt;object type&gt;.get(&quot;&lt;name in config&gt;&quot;);</code>, which effectively just sets the object to the actual object in real life that we need it to be. All the motor values and positions and everything matches up with what’s happening in real life, so the object in the code basically becomes the object in real life for all of our purposes. Now we can work with those values.</p>
<p>The whole statements should look something like this:</p>
<pre><code>leftMotor = hardwareMap.dcMotor.get(&quot;left motor&quot;);
spinner = hardwareMap.crservo.get(&quot;spinner&quot;);
</code></pre>
<h3><a id="Preparing_the_motors_and_servos_449"></a>Preparing the motors and servos</h3>
<p>Now that they’re set up, it’s a good idea to prepare them to actually be used. Technically this step isn’t required, as there are many other ways to get the motors working properly, but it’s a lot easier to reverse directions and set modes here to make the code easier to read and change.</p>
<h4><a id="Setting_Directions_453"></a>Setting Directions</h4>
<p>The first big thing is to set the motor directions. They can either be forward or reverse, and it’s really difficult to know which one you should use before you test, so I recommend just picking one and seeing if it’s correct when you test for the first time. Anyway, to set, you’re going to use <code>setDirection(&lt;direction&gt;)</code>, a method in DcMotor. We don’t really need to understand how this functions directly (although if you’re really interested and have nothing better to do you could probably dig it up somehow), but we do need to understand how to use it.</p>
<p>To use it, you call it on a DcMotor object, with a direction in its parameter. The two directions we have are:</p>
<pre><code>DcMotor.Direction.REVERSE
DcMotor.Direction.FORWARD
</code></pre>
<p>two constants that correspond to forward and backward. After you’re done, the whole statement should look something like this:</p>
<pre><code>leftMotor.setDirection(DcMotor.Direction.REVERSE);
spinner.setDirection(Servo.Direction.FORWARD);
</code></pre>
<h4><a id="Setting_Modes_467"></a>Setting Modes</h4>
<p>The other big thing is to set the all the motors’ modes. There are a few big modes for us to keep in mind:</p>
<ul>
<li><code>DcMotor.RunMode.RUN_WITHOUT_ENCODER</code> - This is probably the most common mode for using during TeleOp, which is simply running without any extra interference or data from encoders that may or may not be attached to the motors. Using <code>setPower(&lt;power&gt;)</code> directly translates to the voltage needed for the motors (0 is the min, 1 is the max; negative values move it in reverse)</li>
<li><code>DcMotor.RunMode.RUN_USING_ENCODER</code> - Probably not too common during TeleOp, but still definitely important to cover. The motors use encoder values and a set max speed to run at specific velocities. This allows for very precise movement, but because TeleOp is controlled by a driver, it’s usually easier and more consistent to just ignore them since joysticks can get the same result with or without encoders. Requires an encoder.</li>
<li><code>DcMotor.RunMode.RUN_TO_POSITION</code> - Very niche uses in TeleOp. This forces the motors to rotate in whatever direction is necessary to get to a certain position. There’s usually no need during TeleOp when you can just drive it to whatever position you need, but it’s possible that this could be used for other motors separate from the drivetrain. Requires an encoder.</li>
<li><code>DcMotor.RunMode.STOP_AND_RESET_ENCODERS</code> - This mode isn’t really intended for use with motors for extended periods of time. It’s just used inside of TeleOp or Autonomous programs to reset the encoder values to 0 (doesn’t move the wheels, just sets the current state as the new 0) and stops the motors. You have to set them to something else after if you want to use them. Requires an encoder.</li>
</ul>
<p>And that’s all of them. So, once you pick the one you think would be most suited for the program, we can actually set it. It’s going to be very similar to setting the direction, just this time we’re using <code>setMode(&lt;mode&gt;)</code>. The end result will be something like this:</p>
<pre><code>leftMotor.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);
rightMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
</code></pre>
<p>You’re all set now! Time to get into the fun stuff!</p>
<h2><a id="The_Loop_483"></a>The Loop</h2>
<p>There are many different ways to make the heart of your driver-controlled OpMode, so I’m just going to give you the tools to do so. There are a ton of samples in FtcRobotController or our code from previous years too if you get stuck.</p>
<p>Put all your code inside <code>public void loop(){ ... }</code> for it to run continuously until the driver hits stop on the app.</p>
<h3><a id="Gamepad_489"></a>Gamepad</h3>
<p>All of these can be accessed by calling them on gamepad1 or gamepad2, corresponding to whichever controllers did Start + A and Start + B on the app, respectively. Every time the loop runs, it will get the current state of the gamepad, so there’s not need to update it like in RobotC or anything.</p>
<ul>
<li><code>gamepad1.a</code> / <code>gamepad1.b</code> / <code>gamepad1.x</code> / <code>gamepad1.y</code> - All the buttons on the gamepad, represented as boolean variables. True means they’re being pushed down, false means that they aren’t.</li>
<li><code>gamepad1.dpad_down</code> / <code>gamepad1.dpad_up</code> / <code>gamepad1.dpad_left</code> / <code>gamepad1.dpad_right</code> - All the values for the directional pad (arrow keys) on the gamepad. Just like the buttons, they’re boolean variables that are true when pushed down or false when not pushed down.</li>
<li><code>gamepad1.left_bumper</code> / <code>gamepad1.right_bumper</code> - The two bumpers of the controller, set up as boolean variables just like all the other buttons. These are really nice because it’s easy to hit them while using the joysticks, but be prepared: every time you call them a bumper, even though that’s what they are, half the team won’t know what button that is. (It’s in front of the trigger, c’mon!)</li>
<li><code>gamepad1.left_trigger</code> / <code>gamepad1.right_trigger</code> - The two triggers. These aren’t buttons, so boolean variables don’t work for these. Instead, they’re set as floats that range from 0 (completely released) to 1 (held down). These are good for things that require a certain degree of variability to speed, but don’t need to go backwards, like spinners or anything that extends out.</li>
<li><code>gamepad1.left_stick_x</code> / <code>gamepad1.left_stick_y</code> / <code>gamepad1.right_stick_x</code> / <code>gamepad1.right_stick_y</code> - The joysticks on the controllers. There are two separate variables for each stick, one for the x axis and one for the y axis. They both range from -1 to 1, representing all the way down and all the way up. These are almost always used for the drivetrain, for the great control they let us have over the robot and how intuitive it is to use.</li>
</ul>
<p>There’s also other buttons and values you can get from the gamepad, but they’re rarely used, since we have two gamepads to work with. It’s fun to make a single gamepad version that uses every button possible, but it’s a lot easier to operate with two drivers, so I didn’t include those other buttons. You can still read about them in the documentation provided by FTC at the top.</p>
<h3><a id="Using_the_Motors_501"></a>Using the Motors</h3>
<p>There are tons of methods to use, especially with encoders, but the one that is used by far the most is <code>setPower(&lt;power&gt;)</code>. It sets a motor’s voltage to nothing (0), full (1), full reverse (-1), and every value in between. Used with the gamepad’s joysticks, it’s easy to translate fully up to full power forwards. Using this with if statements and buttons works particularly well too. It’ll work something like this many times:</p>
<pre><code>leftMotor.setPower(-gamepad1.left_stick_y);
rightMotor.setPower(-gamepad1.right_stick_y);

if(gamepad1.a){
    slider.setPower(1);
} else if (gamepad1.b) {
    slider.setPower(-1);
} else {
    slider.setPower(0);
}
</code></pre>
<p>There’s also <code>getPower()</code>, which returns whatever value the power is currently set to. Not super useful when trying to actually move the robot but incredibly nice when debugging and making sure everything works as intended with telemetry…</p>
<h3><a id="Telemetry_518"></a>Telemetry</h3>
<p>This is the main way of printing things to the phone. Could be a string, could be a number, almost anything. To do this, we will use <code>telemetry.addData(&lt;title&gt;, &lt;value&gt;)</code>.</p>
<p>This takes in two strings as it’s parameters: a title and a value. The title is any string you want, but usually it’s good to just type one in yourself that has some relevance to what it represents. No one’s stopping you from making it a meme though. With a title, it’ll look something like this:</p>
<pre><code>telemetry.addData(&quot;Left Motor&quot;, &lt;value&gt;);
</code></pre>
<p>The value can be almost anything as well, from Strings to floats. The ones that are used the most are values returned from <code>getPower()</code> and <code>getCurrentPosition()</code> (for encoders) or <code>getPosition()</code> (for servos), which help a lot for making sure that motors and encoders are working as intended. With the value inserted as well, the statement’ll look something like this:</p>
<pre><code>telemetry.addData(&quot;Left Motor&quot;, leftMotor.getPower());
</code></pre>
<p>All that’s left is to call <code>telemtry.update();</code>. You only do this once inside the loop, otherwise the output will look super janky as it tries to update twice a frame. This just makes sure that all the values get refreshed and prints them to the screen. At the end of a few statements, your code will probably look something like this:</p>
<pre><code>telemetry.addData(&quot;Left Motor&quot;, leftMotor.getPower());
telemetry.addData(&quot;Right Motor&quot;, rightMotor.getPower());
telemetry.addData(&quot;Spinner&quot;, spinner.getPosition());
telemetry.update();
</code></pre>
<h2><a id="Recap_537"></a>Recap</h2>
<p>Alright, now you know which files you need to import into many TeleOp programs and how to check to make sure you’ve got them all. You also know how to define objects on the robot and link them to their real-world counterparts to allow them to be used in the code. You know how to access values on the gamepad and how to use those to move the motors.</p>
<p>You know how to make a Driver-Controlled OpMode! Nice. :)</p>
<p>If you’re still stuck or want to make sure you’re heading in the right direction, you can check <a href="https://github.com/blabel3/MicdsRobotics/blob/master/ftc_app-master/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/DadDriver.java">our Driver-Controlled OpMode</a>.</p>

</body></html>